---
title: Lock-Free Wait-Free!
first: 在这个人口暴增，访问量暴增的年代，并发是一个避无可避的问题，经过一辈辈人的努力，从单线程到多线程，从排他锁到共享锁，从无锁到有锁，从有锁到无锁，一步步的演变。
layout: default
author:
  name: Aliece TT
  url: http://aliecett.wicp.net
---

在这个人口暴增，访问量暴增的年代，并发是一个避无可避的问题，经过一辈辈人的努力，从单线程到多线程，从排他锁到共享锁，从无锁到有锁，从有锁到无锁，一步步的演变。今天我们就来说说并发编程：

首先我们举个最简单的例子：两个线程A和B修改一个Object，如果我们不做任何操作，那么会出现三种情况：

Thread A : Object.setValue(A);

Thread B : Object.setValue(Object.getValue()+B);

1、A先抢占，修改了Object的Value为A；接着B抢占，修改了Object的Value为A+B。

2、B先抢占，修改了Object的Value为B；接着A抢占，修改了Object的Value为A。

3、线程B得到值＂object＂然后赋给本地变量Value。线程A改变Object的值为A。然后线程B醒来并把变量Object的值改为Value+B;

上面三个情况中只有3是错误的，除非你的场景必须这么做，那1跟2就是错误的了。然后牛逼的我们会马上想到解决方案：加锁。

一、悲观锁（ Pessimistic Locking ）

何为悲观锁呢，它指的是对数据被外界（包括本系统当前的其他事务，以及来自 外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定 状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能 真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系 统不会修改数据）。

一个典型的倚赖数据库的悲观锁调用： 
select * from account where name=”Erica” for update

这条 sql 语句锁定了 account 表中所有符合检索条件（ name=”Erica” ）的记录。 本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。 Hibernate 的悲观锁，也是基于数据库的锁机制实现。 但是这是非常消耗性能的，因为其它线程在系统各处徘徊着准备要获得锁然后又阻塞。线程越多，系统的响应性就会越慢．

二、乐观锁（Optimistic Locking）

相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依 靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库 性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。 如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数据的基础上进 行修改时（如更改用户帐户余额），如果采用悲观锁机制，也就意味着整个操作过 程中（从操作员读出数据、开始修改直至提交修改结果的全过程，甚至还包括操作 员中途去煮咖啡的时间），数据库记录始终处于加锁状态，可以想见，如果面对几百上千个并发，这样的情况将导致怎样的后果。而且，乐观锁带来的更大的问题就是会很容易造成死锁。

所以对于解决这个问题，往往随便的去使用锁来解决并发问题会造成得不偿失的后果。那么还有其他的解决方案么，聪明的程序猿当然会给出一个YES的答案：无锁队列。

相信大家玩并发编程的都听过ring buffer，akka actor，disruptor等等一系列的解决方案； 这里我也不一一介绍了（因为我也没有弄懂-_-）,感兴趣的同学可以去看看相关的博客。[Disruptor](http://www.cnblogs.com/gaiwen/articles/2952845.html)