---
title: Java Basis!
first:  Java Basis
layout: default
author:
  name: Aliece TT
  url: http://aliecett.wicp.net
---

多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。

多态有两种表现形式：重载和覆盖

首先说重载（overload），是发生在同一类中。与什么父类子类、继承毫无关系。标识一个函数除了函数名外，还有函数的参数（个数和类型）。也就是说，一个类中可以有两个或更多的函数，叫同一个名字而他们的参数不同。他们之间毫无关系，是不同的函数，只是可能他们的功能类似，所以才命名一样，增加可读性，仅此而已！

再说覆盖(override),是发生在子类中！也就是说必须有继承的情况下才有覆盖发生。我们知道继承一个类，也就有了父类了全部方法，如果你感到哪个方法不爽，功能要变，那就把那个函数在子类中重新实现一遍。这样再调用这个方法的时候，就是执行子类中的过程了。父类中的函数就被覆盖了。（当然，覆盖的时候函数名和参数要和父类中完全一样,不然你的方法对父类中的方法就不起任何作用，因为两者是两个函数，毫不关系）
 

Hibernate二级缓存

Hibernate中提供了两级Cache，第一级别的缓存是Session级别的缓存，它是属于事务范围的缓存。这一级别的缓存由hibernate管理的，一般情况下无需进行干预；第二级别的缓存是SessionFactory级别的缓存，它是属于进程范围或群集范围的缓存。这一级别的缓存可以进行配置和更改，并且可以动态加载和卸载。 Hibernate还为查询结果提供了一个查询缓存，它依赖于第二级缓存。

一级缓存的管理：

当应用程序调用Session的save()、update()、savaeOrUpdate()、get()或load()，以及调用查询接口的 list()、iterate()或filter()方法时，如果在Session缓存中还不存在相应的对象，Hibernate就会把该对象加入到第一级缓存中。当清理缓存时，Hibernate会根据缓存中对象的状态变化来同步更新数据库。 Session为应用程序提供了两个管理缓存的方法： evict(Object obj)：从缓存中清除参数指定的持久化对象。 clear()：清空缓存中所有持久化对象。

Hibernate二级缓存的管理：

1. Hibernate二级缓存策略的一般过程如下：
1) 条件查询的时候，总是发出一条select * from table_name where …. （选择所有字段）这样的SQL语句查询数据库，一次获得所有的数据对象。
2) 把获得的所有数据对象根据ID放入到第二级缓存中。
3) 当Hibernate根据ID访问数据对象的时候，首先从Session一级缓存中查；查不到，如果配置了二级缓存，那么从二级缓存中查；查不到，再查询数据库，把结果按照ID放入到缓存。
4) 删除、更新、增加数据的时候，同时更新缓存。
Hibernate二级缓存策略，是针对于ID查询的缓存策略，对于条件查询则毫无作用。为此，Hibernate提供了针对条件查询的Query Cache。

2. 什么样的数据适合存放到第二级缓存中？ 
1) 很少被修改的数据 
2) 不是很重要的数据，允许出现偶尔并发的数据 
3) 不会被并发访问的数据 
4) 参考数据,指的是供应用参考的常量数据，它的实例数目有限，它的实例会被许多其他类的实例引用，实例极少或者从来不会被修改。

3. 不适合存放到第二级缓存的数据？ 
1) 经常被修改的数据 
2) 财务数据，绝对不允许出现并发 
3) 与其他应用共享的数据。

4. 常用的缓存插件 Hibernater二级缓存是一个插件，下面是几种常用的缓存插件：
◆EhCache：可作为进程范围的缓存，存放数据的物理介质可以是内存或硬盘，对Hibernate的查询缓存提供了支持。
◆OSCache：可作为进程范围的缓存，存放数据的物理介质可以是内存或硬盘，提供了丰富的缓存数据过期策略，对Hibernate的查询缓存提供了支持。
◆SwarmCache：可作为群集范围内的缓存，但不支持Hibernate的查询缓存。
◆JBossCache：可作为群集范围内的缓存，支持事务型并发访问策略，对Hibernate的查询缓存提供了支持。

5. 配置Hibernate二级缓存的主要步骤：
1) 选择需要使用二级缓存的持久化类，设置它的命名缓存的并发访问策略。这是最值得认真考虑的步骤。
2) 选择合适的缓存插件，然后编辑该插件的配置文件。


线程的join()方法，是 阻塞调用线程，直到某个线程终止或经过了指定时间为止 

thread2.Start(); 
thread1.Start(); 
   
//阻塞主线程，直到thread1线程终止为止 
//这时在thread1没有执行完，后面的代码是无法执行的。 
//当然thread2执不执行完是不管的，并且thread1与thread2是同时无顺运行的。 
thread1.Join(); 

CountDownLatch一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。
[http://www.iteye.com/topic/1002652](http://www.iteye.com/topic/1002652)
